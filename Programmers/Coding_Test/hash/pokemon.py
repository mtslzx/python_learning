'''
문제 설명

당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.
홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.
첫 번째(3번), 두 번째(1번) 폰켓몬을 선택
첫 번째(3번), 세 번째(2번) 폰켓몬을 선택
첫 번째(3번), 네 번째(3번) 폰켓몬을 선택
두 번째(1번), 세 번째(2번) 폰켓몬을 선택
두 번째(1번), 네 번째(3번) 폰켓몬을 선택
세 번째(2번), 네 번째(3번) 폰켓몬을 선택
이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.
당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.
제한사항
nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.
nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.
폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.
가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.

입출력 예
nums	        result
[3,1,2,3]	    2
[3,3,3,2,2,4]	3
[3,3,3,2,2,2]	2

입출력 예 설명
입출력 예 #1
문제의 예시와 같습니다.
입출력 예 #2
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.
입출력 예 #3
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.
'''

# 참조 : https://wikidocs.net/16039

def solution(nums):
    nums.sort()  # 오름차순 정렬
    temp = nums[0]
    answer = list()
    for i in range(len(nums)):
        if nums[i+1] == nums[-1]:
            answer.append(nums[-1])
            break
        while temp == nums[i]:
            nums.remove(temp)
            # i -= 1
        answer.append(temp)
        temp = nums[i]
    answer = len(answer)
    return answer

'''
원본 배열을 수정하는걸로 답을 구할 순 없을까..? map이랑 filter 함수로도 할 수 있을것 같은데
def solution(nums):
    nums.sort()  # 오름차순 정렬
    temp = nums[0]
    for i in range(len(nums)):
        if nums[i] == nums[-1]:
            break
        while temp == nums[i]:
            nums.remove(temp)
            # i -= 1
        temp = nums[i]
    answer = len(nums)  # 리스트의 길이가 곧 폰켓몬의 총 종류가 됨
    return answer
'''



nums = [1,1,1,1,2,2,4,3,3,3,3,3,3,2,2,4,5]
print(solution(nums))

'''
def solution(nums):
    nums.sort()  # 오름차순 정렬
    for i in nums:
        temp = nums[i]
        if temp == nums[i]:
            nums.remove(temp)
    answer = len(nums)  # 리스트의 길이가 곧 폰켓몬의 종류가 됨
    return answer
    ----------------------------------------------------------------
    원래 하려고 했던 방식이 temp에 첫번째 원소를 넣고 다음번째 원소와 비교하며 같은 값을 찾으면 삭제하는 방식이었는데
    이것도 되게 C적인 방식이더라고? 그래서 참조한 코드를 보고 다시 풀어봤음
    리스트 관련 Method로 count(item)가 있는데 얘가 리스트에서 매칭되는 갯수를 리턴해주는데 이걸 활용했지
    근데 이걸 하려했는데 개어려워지네 그래서 그냥 원래방식 다시간다...
    무슨 생각까지 했었냐면, [3, 3, 3, 2, 2, 2, 1, 1] 이런 리스트가 있을때
    count 매소드로 3이 3개, 2가 3개, 1이 2개 있으니까 경우의 수를 3개를 고르면 되는거지
    이럴려면 튜플인가 키?인가 밸류인가 그런거 써야되는데 그걸 몰라서 그냥 포기했음
    무엇보다 종류번호가 20만까지 가는데 키를 그렇게 만들 생각도 없고..
    그걸 안쓰고 하려하니깐 이상한 방식으로 접근하게 되는거 같아서 포기했음
    저 예시에서 3, 3, 3, 2, 2, 2, 1, 1 이렇게 있으면
    카운트 for문에 넣어서 돌렸다 하면 count의 리턴값 3만 6번 나오고 2만 2번 나오는데
    이렇게 중복되는 친구들을 어떻게 처리해야할지 머리가 안돌아가서..
    아 아닌가 3을 3으로 나누고 2를 2로 나누면 2 + 1 = 3 경우의 수 3?
    다른 예시 [3, 3, 3, 2, 2, 4]가 있을때 
    카운트 리턴값 3, 3, 3, 2, 2, 1이 나올거고
    3 3개고 2 2개고 1 1개일때 각각 나눗셈시 1 + 1 + 1 경우의 수 3
    오?!
    근데 포문 20만 까지 돌려야하는...데
    포문을 리스트 원소 수만큼 돌리는게 훨씬 효율적이지 않을까 싶으면서도...
    아 몰라 언젠간 다시 읽게된다면 해보던가 하겠지..
    
'''