# 1259번: 팰린드롬수 - <img src="https://static.solved.ac/tier_small/5.svg" style="height:20px" /> Bronze I

<!-- performance -->

![](https://img.shields.io/badge/Python-3670A0?style=flat-square&logo=python&logoColor=white) ![](https://img.shields.io/badge/BOJ-Passed-Success?style=flat-square) ![](https://img.shields.io/badge/Memory_Usage-34906KB-informational?style=flat-square) ![](https://img.shields.io/badge/Time_Spend-72ms-informational?style=flat-square)

팰린드롬수는 앞뒤로 어떻게 읽어도 같은 수이니 가운데까지만 확인하면 될 것 같다.
우선 문자열을 입력받은 뒤, 문자열을 리스트로 만들고 리스트를 앞과 뒤, 그리고 가운데 값을 분리한다.
아, 그냥 pop, popleft로 리스트 양쪽 끝에서 하나씩 빼서 교차 검증을 하면 될 것 같다.
오류를 방지하기 위해 가운데 값은 먼저 제거하고, 리스트의 길이를 계산해 반복문을 돌려주자.

가운데 값을 제거할 필요는 없었고, 리스트의 양쪽 끝에서 부터 하나씩 pop을 통해 값을 빼오는 방식이다.
양 끝값이 다를 경우 팰린드롬수가 아니므로 아니라고 출력한다.
그렇게 덱에서 값을 빼다가 남은 원소가 하나 (문자열의 길이가 홀수인 경우) 또는 원소가 없을 경우 (문자열의 길이가 짝수인 경우). 양 끝의 모든 원소가 일치하는 것을 확인하였으므로 팰린드롬수가 맞다고 출력한다.

팰린드롬수는 무조건 홀수여야 가능하다고 생각했는데 그게 아니었다...
짝수인 경우도 있었으므로 다시 코드를 짜야한다.

마지막으로 빼먹은 조건이 한자리수인 경우이다. 한자리수는 그 자체로 팰린드롬수라고 볼 수 있으므로, 한자리수에 대한 예외를 만들었다.

<!-- end -->

## 문제

[문제 링크](https://boj.kr/1259)


<p>어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.</p>

<p>수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.</p>



## 입력

입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.

## 출력

각 줄마다 주어진 수가 팰린드롬수면 'yes', 아니면 'no'를 출력한다.

## 소스코드

[소스코드 보기](팰린드롬수.py)
